Racket (ранее — PLTScheme) — мультипарадигменный язык программирования общего назначения, принадлежащий семейству Lisp/Scheme. Предоставляет среду языково-ориентированное программирование — одно из предназначений racket — создание, разработка и реализация языков программирования. Язык используется в различных контекстах: как скриптовый язык, как язык общего назначения, в обучении информатике, в научных исследованиях.

Платформа предоставляет пользователю реализацию языка Racket, включая развитую среду выполнения (англ. run time system), различные библиотеки, JIT-компилятор и т. д., а также среду разработки DrRacket (ранее известную, как DrScheme) написанную на Racket. Эта программная среда используется в учебном курсе ProgramByDesign[en] массачусетского технологического института. Основной язык Racket отличает мощная макросистема, позволяющая создавать встраиваемые и предметно-ориентированные языки программирования, языковые конструкции (к примеру, классы и модули) и диалекты Racket с различной семантикой.

Система является свободным и открытым ПО, распространяемым на условиях LGPL. Расширения и пакеты, написанные сообществом, доступны на PLaneT, веб-дистрибутиве системы.
Создание
Матиас Феллайзен[en] основал компанию PLT Inc. в середине 1990-х, первоначально — как исследовательскую группу, а затем — как проект по разраработке и выпуску педагогических материалов для начинающих программистов (лекции, упражнения/проекты, программное обеспечение). В январе 1995 было решено разработать учебную среду программирования на языке Scheme. Мэтью Флэтт[en] собрал MrEd — оригинальную виртуальную машину Racket, используя libscheme, wxWidgets и некоторые другие свободные системы. В течение последующих лет команда, в которую входили, в частности, Флэтт, Роберт Брюс Финдлер[en], Шрирам Кришнамурти[en], Cormac Flanagan, и многие другие, выпускала среду DrScheme, предназначенную для начинающих программистов-схемеров и исследований в области мягкой типизации (комбинации статической и динамической типизации). Основной язык программирования, поддерживавшийся средой, назывался PLT Scheme.

Параллельно с этим команда начала проведение семинаров для учителей средней школы, обучая их разработке программ и функциональному программированию. Полевые испытания с этими учителями и их учениками определили основные направления развития продукта.

DrScheme был дополнен учебными языками, пошаговым алгебраическим вычислителем (англ. algebraic stepper), прозрачным REPL-циклом, подсистемой печати на основе конструкторов (cons) и множеством других нововведений, которые сделали DrScheme качественным образовательным продуктом. В 2001 году разработчиками языка был написан и опубликован учебник How to Design Programs[en], основанный на их философии обучения программированию.

Развитие DrScheme
В первое поколение версий DrScheme были введены средства для «программирования в большом[en]» c использованием модулей и классов. В версии 42 были добавлены юниты: система модулей — объектов первого класса, позволяющая дополнять модули в процессе разработки больших систем. Система классов была с одной стороны дополнена (в частности, интерфейсами в стиле Java), а с другой — сокращена (в частности было удалено множественное наследование). Язык развивался на протяжении ряда последовательных версий и набрал популярность к версии 53, что ещё ускорило работу над ним и следующая версия 100, стала эквивалентом «1.0».

В следующую крупную ревизию, получившую номер 200, была введена новая модульная система по умолчанию, интегрированная с макросами. В частности, модульная система гарантирует, что вычисления времени выполнения и вычисления времени компиляции разделены для поддержки «башни языков». В отличие от юнитов, эти модули не являются объектами первого класса.

В версию 300 введена поддержка Unicode, библиотека интерфейса с внешними функциями[en] и изменена система классов. Позднее для релизов версии 300 была улучшена производительность путём добавления JIT-компилятора и сборки мусора с поддержкой поколений объектов.

К следующему мажорному релизу DrScheme перешёл на общепринятую систему нумерации версий на основе десятичных дробей. В версию 4.0 введено сокращение #lang для указания [под]языка, на котором написан модуль. Также в этот релиз введены неизменяемые пары и списки, поддержка мелкозернистого параллелизма, и статически типизированный диалект.

Racket
7 июня 2010 года PLT Scheme был переименован в Racket, что совпало с выпуском версии 5.0. Впоследствии, в версии 5.1, базовая программа GUI была переписана с C++ на Racket c помощью собственного инструментария пользовательского интерфейса на всех платформах. В версии 5.2 включен инструмент фоновой проверки синтаксиса, новую библиотеку-плоттер, библиотеки баз данных и новый расширенный REPL. В версию 5.3 включена новая функциональность: подмодули для опционально загружаемых модулей, новые инструменты оптимизации, библиотека JSON, и другие возможности. В версии 5.3.1 значительно улучшен DrRacket: добавлен новый инструмент просмотра документации, проверка синтаксиса в фоне включена по умолчанию.

Основным новшеством версии 6.0, выпущенной 24 февраля 2014 года стала новая система пакетов, дистрибутив Racket стал модульным, он состоит из более 200 пакетов. Появилась возможность установки Minimal Racket, где эти пакеты не предустановлены. Также была добавлена поддержка JIT-компиляции для архитектуры ARM, значительно улучшено быстродействие Typed Racket и т. д.

Основные нововведение версии 7.0, выпущенной в конце июля 2018, связаны с подготовкой замены собственной виртуальной машины Racket на Chez Scheme.

Racket Chez Scheme
С начала 2017 года систему макросов и модулей Racket стали переписывать с целью замены сделанной на языке Си виртуальной машины на Chez Scheme, а также улучшения переносимости и облегчения поддержки Racket. Данный форк Racket известен как Racket CS. В январе 2019 года было объявлено о достижении полной функциональности Racket on Chez Scheme. Хотя код, скомпилированный Racket CS, обычно выполняется также быстро, как и для классического Racket, и иногда даже быстрее, общая производительность пока не была признана достаточной, чтобы сделать Racket CS реализацией Racket по умолчанию. В частности упала скорость компиляции и время запуска Racket-системы Начиная с версии Racket 7.4, выпущенной 8 августа 2019 года вариант RacketCS получил статус бета-версии, доступной для загрузки с официальной страницы языка программирования.

Примеры кода
Тривиальная программа «hello world» будет выглядеть следующим образом:

#lang racket
"Hello, World!"
При её запуске будет выведено:

«Hello, World!»
Вот чуть менее тривиальная программа:


Результат программы, который покажет DrRacket
#lang racket
(require 2htdp/image)
(let sierpinski ([n 8])
  (if (zero? n)
    (triangle 2 'solid 'red)
    (let ([t (sierpinski (- n 1))])
      (freeze (above t (beside t t))))))
Данная программа, взятая с сайта Racket, нарисует треугольник Серпинского с глубиной вложенности 8.

Пример использования генератора:

#lang racket
(require racket/generator)
(define fib
  (generator
   () (let loop ((x 1)
                 (y 1))
        (yield x)
        (loop y (+ x y)))))
Используя директиву #lang, можно писать программы на альтернативных диалектах Racket’a. Вот пример факториала на Typed Racket, диалекте со статической типизацией:
```Racket
#lang typed/racket
(: fact (Integer -> Integer))
(define (fact n)
  (cond [(zero? n) 1]
        [else (* n (fact (- n 1)))]))
```
Режим совместимости со стандартом языка Scheme выбирается директивой #lang R6RS или #lang R5RS, соответственно.
